---
title: C语言简明笔记
published: 2026-02-23
updated: 2026-02-25
description: 'C语言简单笔记'
image: ''
tags: [编程语言]
category: '编程'
draft: false 
lang: ''
---
```c
#include<stdio.h>

int main(){
    printf("Hello world\n");
}
```
+ 编译运行
    ```bash
       gcc a.c -o a -g && ./a
    ```

# 字符串

+ 使str指向字符串的第一个字符。

```c
#include<stdio.h>

int main(){
    char *str;
    str = "Hello world\n";
    printf("%s",str);
}
```

## 访问字符串中的字符

```c
#include<stdio.h>

int count_spaces(const char s[]){
    int c = 0;
    int i;
    for(i = 0;s[i] != '\0';i ++){
        if(s[i] == ' ') c ++;
    }
    return c;
}

int main(){
    char *str;
    str = "Hello the world of C\n";
    printf("%s",str);
    printf("%d\n",count_spaces(str));
}
```

## 使用 C 语言的字符串库

在 C 语言中把字符串当作数组来处理,因此对字符串的限制方式和对数组的一样,特别是它们都不能用 C 语言的运算符进行复制和比较操作。

C 语言的函数库为完成对字符串的操作提供了丰富的函数集。这些函数的原型驻留在`<string.h>`头

### strncpy()
```c
#include<stdio.h>
#include<string.h>

int main(){
    char *str;
    str = "Hello the world of C\n";
    printf("%s",str);
    char str1[10] = "";
    char str2[30] = "";
    strncpy(str1, str, sizeof(str1) - 1);
    strncpy(str2, str, sizeof(str2) - 1);
    printf("%s\n",str1);
    printf("%s",str2);
}
```
### strncat()
```c
#include<stdio.h>
#include<string.h>

int main(){
    char *str;
    str = "Hello the world of C\n";
    printf("%s",str);
    char str1[40] = "";
    
    // strncat(目标数组, 源字符串, 目标数组剩余空间)
    strncat(str1, str, sizeof(str1) - strlen(str1) - 1);
    strncat(str1, str, sizeof(str1) - strlen(str1) - 1);
    
    // 确保字符串以 \0 结尾
    str1[sizeof(str1) - 1] = '\0';

    printf("%s", str1);
}
```

## 自实现简单字符串常用函数

### substr()

#### 完全版

```c
/**
 * @brief 实现C++ string::substr的功能
 * @param str 原字符串（不能为空）
 * @param pos 起始位置（从0开始计数）
 * @param len 要截取的长度（如果为0或超过剩余长度，则截取到字符串末尾）
 * @return 截取后的子字符串（需要调用者手动free释放内存），失败返回NULL
 */
char* substr(const char* str, size_t pos, size_t len) {
    // 1. 基础参数校验
    if (str == NULL) {
        printf("错误：原字符串不能为空\n");
        return NULL;
    }

    // 2. 获取原字符串长度
    size_t str_len = strlen(str);

    // 3. 检查起始位置是否越界
    if (pos >= str_len) {
        printf("错误：起始位置%zu超出字符串长度%zu\n", pos, str_len);
        return NULL;
    }

    // 4. 计算实际要截取的长度
    size_t actual_len;
    if (len == 0 || (pos + len) > str_len) {
        // 如果len为0或截取范围超出字符串末尾，则截取到末尾
        actual_len = str_len - pos;
    } else {
        actual_len = len;
    }

    // 5. 分配内存（+1 用于存储字符串终止符'\0'）
    char* result = (char*)malloc(actual_len + 1);
    if (result == NULL) {
        printf("错误：内存分配失败\n");
        return NULL;
    }

    // 6. 拷贝子字符串（从pos位置开始，拷贝actual_len个字符）
    strncpy(result, str + pos, actual_len);
    // 手动添加终止符（strncpy在拷贝满长度时不会自动加）
    result[actual_len] = '\0';

    return result;
}
```

#### 测试样例

```c
void test(){
    const char* original = "Hello, World!";
    
    // 测试1：截取从索引7开始，长度5的子串（"World"）
    char* sub1 = substr(original, 7, 5);
    printf("测试1: %s\n", sub1);
    free(sub1);  // 必须释放内存

    // 测试2：截取从索引0开始，长度5的子串（"Hello"）
    char* sub2 = substr(original, 0, 5);
    printf("测试2: %s\n", sub2);
    free(sub2);

    // 测试3：截取长度超出剩余字符（自动截取到末尾）
    char* sub3 = substr(original, 5, 20);
    printf("测试3: %s\n", sub3);
    free(sub3);

    // 测试4：起始位置越界（返回NULL）
    char* sub4 = substr(original, 20, 5);
    if (sub4 == NULL) {
        printf("测试4: 截取失败（起始位置越界）\n");
    }
}
```

#### 简化板子

```c
char* substr(const char* str, size_t pos, size_t len) {
    // 基础参数校验
    if (str == NULL) {
        exit(0);
        return NULL;
    }

    //获取原字符串长度
    size_t str_len = strlen(str);

    //检查起始位置是否越界
    if (pos >= str_len) {
        exit(0);
        return NULL;
    }

    // 计算实际要截取的长度
    size_t actual_len;
    if (len == 0 || (pos + len) > str_len) {
        // 如果len为0或截取范围超出字符串末尾，则截取到末尾
        actual_len = str_len - pos;
    } else {
        actual_len = len;
    }

    // 5. 分配内存（+1 用于存储字符串终止符'\0'）
    char* result = (char*)malloc(actual_len + 1);
    if (result == NULL) {
        exit(0);
        return NULL;
    }

    // 拷贝子字符串（从pos位置开始，拷贝actual_len个字符）
    strncpy(result, str + pos, actual_len);
    // 手动添加终止符（strncpy在拷贝满长度时不会自动加）
    result[actual_len] = '\0';

    return result;
}
```

<!-- 基础版（适配Markdown渲染环境） -->
<div style="
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    padding: 16px;
    margin: 10px 0;
    background: #f6f8fa;
    transition: all 0.2s;
">
  <a href="https://www.cnblogs.com/xugangfan/p/19306262" target="_blank" style="
      text-decoration: none;
      color: inherit;
      display: block;
  ">
    <h3 style="
        margin: 0 0 8px 0;
        color:rgb(245, 9, 186);
        font-size: 1.1em;
    "> C语言字符串函数全面详解（优化版）</h3>
    <p style="
        margin: 0;
        color: #586069;
        font-size: 0.9em;
    ">本链接链接至C语言字符串函数全面详解（优化版），为建议阅读内容</p>
  </a>
</div>

# 结构、联合和枚举

+ 结构是可能具有不同类型的值(成员)的集合。

+ 联合和结构很类似,不同之处在于联合的成员共享同一存储空间。这样的结果是,联合可以每次存储一个成员,但是无法同时存储全部成员。

+ 枚举是一种整数类型,它的值由程序员来命名。

## 结构

+ 每个结构代表一种新的作用域。任何声明在此作用域内的名字都不会和程序中的其他名字冲突。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

const int NAME_LEN = 30;

struct empolyee
{
    int age;
    char name[NAME_LEN + 1];
    int salary;
};

void print(struct empolyee x){
    printf("%d\n",x.age);
    puts(x.name);
    printf("%d\n",x.salary);
}

int main(){
    struct empolyee a = {.name = "Lemon Tree", .salary = 100000, .age = 20};
    print(a);
    return 0;
}
```

+ 除了声明结构标记,还可以用 typedef 来定义真实的类型名。
+ 传指针避免值拷贝
+ `{.name = "Lemon Tree", .salary = 100000, .age = 20}` 被称为 `指示器`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

// 宏定义规范：常量改用#define且全大写
#define NAME_LEN 30


// 增加typedef简化结构体使用
typedef struct Employee {
    int age;
    char name[NAME_LEN + 1];  // 字符数组用于存储姓名
    int salary;
} Employee;

//   函数优化：
// - 传指针避免值拷贝，const保证参数不被修改
// - 增加空指针断言，提升鲁棒性
void printEmployee(const Employee* emp) {
    // 断言防止空指针传入导致程序崩溃
    assert(emp != NULL);
    
    printf("%d\n", emp->age);
    puts(emp->name);
    printf("%d\n", emp->salary);
}

int main() {
    Employee a = {.age = 20, .name = "Lemon Tree", .salary = 100000};
    
    // 传地址调用函数，减少内存拷贝
    printEmployee(&a);
    
    return 0;
}
```

### 利用结构整体赋值

+ 除了赋值运算,C 语言没有提供其他用于整个结构的操作。

```c
int main() {
    Employee a = {.age = 20, .name = "Lemon Tree", .salary = 100000};
    
    // 传地址调用函数，减少内存拷贝
    printEmployee(&a);
    
    Employee b = a;
    b.age ++;
    printEmployee(&b);
    return 0;
}
```

## 联合

```c
#include <stdio.h>

#define INT_KIND    0
#define DOUBLE_KIND 1

typedef struct {
    int kind;  /* tag field */
    union {
        int i;
        double d;
    } u;
} Number;

// 打印 Number 类型的值
void printNumber(const Number *num) {
    switch (num->kind) {
        case INT_KIND:
            printf("Integer: %d\n", num->u.i);
            break;
        case DOUBLE_KIND:
            printf("Double: %.2f\n", num->u.d);
            break;
        default:
            printf("Unknown kind\n");
    }
}
```

+ 测试样例

```c
void test(){
    Number num1, num2;

    // 初始化一个整数类型
    num1.kind = INT_KIND;
    num1.u.i = 42;

    // 初始化一个浮点数类型
    num2.kind = DOUBLE_KIND;
    num2.u.d = 3.14159;

    // 打印结果
    printNumber(&num1);
    printNumber(&num2);
}
```

### 匿名联合

```c
#include <stdio.h>
#include <assert.h>

// 类型标记宏定义（规范且语义化）
#define NUM_TYPE_INT    1
#define NUM_TYPE_FLOAT  2

// 仅保留匿名联合版本的结构体，typedef简化声明
typedef struct {
    int type;               // 数据类型标记：1=int，2=float
    union {                 // 匿名联合：成员直接提升到父结构体作用域
        int ival;           // 整数值（可直接通过结构体变量访问）
        float fval;         // 浮点数值（可直接通过结构体变量访问）
    };
} NumberAnonymous;

// 封装打印逻辑，增加空指针校验和错误处理
void printNumber(const NumberAnonymous* num) {
    assert(num != NULL);  // 防止空指针传入
    switch (num->type) {
        case NUM_TYPE_INT:
            printf("整数值：%d\n", num->ival);  // 直接访问，无需 .u
            break;
        case NUM_TYPE_FLOAT:
            printf("浮点值：%.2f\n", num->fval);  // 直接访问，无需 .u
            break;
        default:
            printf("错误：未知的数据类型（type=%d）\n", num->type);
    }
}
```

+ 测试

```c
void test(){
    // 初始化整数类型
    NumberAnonymous num1 = {
        .type = NUM_TYPE_INT,
        .ival = 100  // 直接赋值，无需 .u.ival
    };
    
    // 初始化浮点类型
    NumberAnonymous num2 = {
        .type = NUM_TYPE_FLOAT,
        .fval = 3.14159f  // 直接赋值，无需 .u.fval
    };

    // 测试打印
    printNumber(&num1);
    printNumber(&num2);
}
```
## 枚举

```c
#include <stdio.h>
#include <assert.h>

typedef struct {
    // 用枚举声明标记字段，替代之前的宏
    enum { INT_KIND, DOUBLE_KIND } kind;
    // 匿名联合，成员直接提升到结构体作用域
    union {
        int i;
        double d;
    };
} Number;

// 打印函数：根据枚举标记安全访问联合成员
void printNumber(const Number *num) {
    assert(num != NULL);
    switch (num->kind) {
        case INT_KIND:
            printf("整数: %d\n", num->i);
            break;
        case DOUBLE_KIND:
            printf("双精度浮点数: %.2f\n", num->d);
            break;
        default:
            printf("错误: 未知的 Number 类型\n");
    }
}
```

+ test

```c
void test(){
    // 初始化一个整数类型的 Number
    Number num1 = {
        .kind = INT_KIND,
        .i = 42
    };

    // 初始化一个双精度浮点数类型的 Number
    Number num2 = {
        .kind = DOUBLE_KIND,
        .d = 3.14159
    };

    printNumber(&num1);
    printNumber(&num2);
}
```

# 指针的高级应用

## 动态存储分配

+ C 语言支持动态存储分配,即在程序执行期间分配内存单元的能力。
+ 利用动态存储分配,可以设计出能根据需要扩大(和缩小)的数据结构。 
+ 为了动态地分配存储空间,需要调用三种内存分配函数的一种,这些函数都是声明在`<stdlib.h>`头中的。
    + `malloc 函数`——分配内存块,但是不对内存块进行初始化。     
    + `calloc 函数`——分配内存块,并且对内存块进行清零。 
    + `realloc 函数`——调整先前分配的内存块大小。
+ 函数会返回 `void * 类型`的值。`void *类型`的值是“通用”指针,它本质上只是内存地址。 

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

void test1(){
    int n;scanf("%d",&n);
    int *a = (int *)malloc(n * sizeof(int));
    if(a == NULL) exit(1);
    for(int i = 0;i < n;i ++) printf("%d ",a[i]);
    printf("\n");
    free(a);
}

void test2(){
    int n;scanf("%d",&n);
    int *a = (int *)calloc(n ,sizeof(int));
    if(a == NULL) exit(1);
    for(int i = 0;i < n;i ++) printf("%d ",a[i]);
    printf("\n");
    free(a);
}

void test3(){
    int n;scanf("%d",&n);
    int *a = (int *)calloc(n ,sizeof(int));
    if(a == NULL) exit(1);
    for(int i = 0;i < n;i ++) a[i] = i + 1;

    int m;scanf("%d",&m);
    int *b = (int *)realloc(a,(n + m) * sizeof(int));
    if(b == NULL){
        free(a);  // 扩容失败，释放原内存
        exit(1);  // 新增：扩容失败直接退出，避免后续操作
    }
    a = b;  // 关键：将原指针指向新的内存地址
    for(int i = n;i < n + m;i ++) a[i] = (i + 1) * (i + 1) * (i + 1);
    for(int i = 0;i < n + m;i ++) printf("%d ",a[i]);
    printf("\n");
    free(a);  // 释放扩容后的内存（等价于free(b)）
}

int main(){
    test1();
    test2();
    test3();
    return 0;
}
```

+ 关于`realloc 函数`的规则
    + 当扩展内存块时,`realloc 函数`不会对添加进内存块的字节进行初始化。
    + 如果 `realloc 函数`不能按要求扩大内存块, 那么它会返回`空指针`, 并且在原有的内存块中的数据`不会`发生改变。
    +  如果 `realloc 函数`被调用时以 `0` 作为第二个实际参数,那么它会`释放内存块`。
+ 一旦 `realloc 函数`返回, 请一定要对指向内存块的`所有指针`进行更新, 因为 `realloc 函数`可能会使内存块移动到其他地方。

### 悬空指针

+ 虽然 `free 函数`允许收回不再需要的内存,但是使用此函数会导致一个新的问题:`悬空指针(dangling pointer)` 。
+ 调用 `free(p)函数`会释放` p `指向的内存块,但是不会改变` p `本身。
+ 如果忘记了` p `不再指向有效内存块,`混乱`可能随即而来
    + 所以建议 `free` 后置 `NULL`

```c
    free(a);
    a = NULL;
```

## 指向函数的指针

+ C 语言没有要求指针只能指向数据, 它还允许`指针指向函数`。
    + 毕竟函数`占用内存单元`,所以每个函数都有 `地址`,就像每个`变量`都有`地址`一样。
    ``` c
        #include <stdio.h>
        #include <math.h>  // 用于 sin 函数

        // 定义积分函数：参数是一个函数指针 f
        double integrate(double (*f)(double), double a, double b) {
            const int n = 1000000;  // 把区间分成10000份，份数越多越精确
            double h = (b - a) / n;  // 每个小矩形的宽度
            double sum = 0.0;

            for (int i = 0; i < n; i++) {
                double x = a + i * h;  // 取每个小矩形左端点的 x
                sum += f(x);           // 调用传入的函数 f(x)
            }
            return sum * h;  // 所有矩形面积之和 ≈ 积分值
        }

        // 测试函数1：f(x) = x²
        double square(double x) {
            return x * x;
        }

        // 测试函数2：f(x) = 2x + 1
        double linear(double x) {
            return 2 * x + 1;
        }

        void test(){
            // 1. 计算 sin(x) 从 0 到 π/2 的积分
            double pi = acos(-1.0);
            double result1 = integrate(sin, 0.0, pi / 2);
            printf("∫₀^(π/2) sin(x) dx ≈ %.6f\n", result1);  // 理论值是 1.0

            // 2. 计算 x² 从 0 到 2 的积分
            double result2 = integrate(square, 0.0, 2.0);
            printf("∫₀² x² dx ≈ %.6f\n", result2);  // 理论值是 8/3 ≈ 2.666667

            // 3. 计算 2x+1 从 1 到 3 的积分
            double result3 = integrate(linear, 1.0, 3.0);
            printf("∫₁³ (2x+1) dx ≈ %.6f\n", result3);  // 理论值是 10.0
        }
    ```
+ 举例 `int (*f)(double)`

| 语法片段 | 优先级 / 结合性 | 具体含义                                                         |
| :------- | :-------------- | :--------------------------------------------------------------- |
| `(*f)`   | 最高（括号）    | f 是一个指针变量，括号强制让 f 先和 * 结合，明确是“指针”而非“函数” |
| `(double)`| 次之            | 这个指针指向的函数接收 1 个 double 类型的参数                    |
| `int`    | 最低            | 这个指针指向的函数返回值是 int 类型                             |

### qsort()

+ `qsort()函数`的原型可以在`<stdlib.h>`中找到。
+ `函数 qsort()` 是给任意数组排序的`通用函数`。
+ 函数原型如下
    + ```c
       void qsort(void *base, size_t nmemb, size_t size,int (*compar) (const void *, const void *));
       ```
    + 可以采用函数 qsort 的下列调用方式
    + ```c
       qsort(inventory, num_parts, sizeof(struct part), compare_parts);
       ```
    + 最后一个`实际参数 compare_parts` 是比较两个 part 结构的`函数`。
+ 例子
    ```c
        #include <stdio.h>
        #include <stdlib.h>

        // 定义学生结构体
        typedef struct {
            char name[20];  // 学生姓名
            int id;         // 学号
            float score;    // 成绩
        } Student;

        // 比较函数：按成绩升序排序
        // 返回值规则：
        //   < 0: a 排在 b 前面
        //   = 0: a 和 b 相等
        //   > 0: b 排在 a 前面
        int compare_students(const void *a, const void *b) {
            // 将 void* 指针转换为 Student* 指针
            const Student *student_a = (const Student *)a;
            const Student *student_b = (const Student *)b;

            // 比较成绩，注意浮点数不能直接返回差值，要判断大小
            if (student_a->score < student_b->score) {
                return -1;
            } else if (student_a->score > student_b->score) {
                return 1;
            } else {
                return 0;
            }
        }

        int main() {
            // 初始化学生数组
            Student students[] = {
                {"Alice", 1001, 85.5},
                {"Bob", 1002, 92.0},
                {"Charlie", 1003, 78.3},
                {"David", 1004, 90.1},
                {"Eve", 1005, 88.7}
            };
            int num_students = sizeof(students) / sizeof(students[0]);

            // 打印排序前的成绩
            printf("排序前:\n");
            for (int i = 0; i < num_students; i++) {
                printf("姓名: %-10s 学号: %d 成绩: %.1f\n",
                    students[i].name, students[i].id, students[i].score);
            }

            // 调用 qsort 进行排序
            qsort(students, num_students, sizeof(Student), compare_students);

            // 打印排序后的成绩
            printf("\n排序后（按成绩升序）:\n");
            for (int i = 0; i < num_students; i++) {
                printf("姓名: %-10s 学号: %d 成绩: %.1f\n",
                    students[i].name, students[i].id, students[i].score);
            }

            return 0;
        }
    ```
+ 简化版的`qsort()调用`
```c
#include <stdio.h>
#include <stdlib.h>

// 比较函数：用于整数升序排序
int compare_ints(const void *a, const void *b) {
    // 将void指针转换为int指针，并取值比较
    int num1 = *(const int *)a;
    int num2 = *(const int *)b;
    
    // 直接返回差值即可（升序），负数/0/正数对应排序规则
    return num1 - num2;
}

int main() {
    // 原始成绩数组
    int scores[] = {85, 92, 78, 90, 88, 65, 95};
    // 计算数组长度
    int n = sizeof(scores) / sizeof(scores[0]);

    // 排序前
    printf("排序前的成绩数组：");
    for (int i = 0; i < n; i++) {
        printf("%d ", scores[i]);
    }
    printf("\n");

    // 调用qsort排序
    // 参数：数组首地址、元素个数、单个元素大小、比较函数
    qsort(scores, n, sizeof(int), compare_ints);

    // 排序后
    printf("排序后的成绩数组（升序）：");
    for (int i = 0; i < n; i++) {
        printf("%d ", scores[i]);
    }
    printf("\n");

    return 0;
}
```
## 函数指针的数组

```c
#include <stdio.h>
#include <stdlib.h>

// 定义几个命令函数
void new_cmd()  { printf("执行：新建文件\n"); }
void open_cmd() { printf("执行：打开文件\n"); }
void save_cmd() { printf("执行：保存文件\n"); }
void exit_cmd() { printf("执行：退出程序\n"); exit(0); }

int main() {
    // 1. 演示单个函数指针变量
    void (*cmd_pf)(void);  // 声明函数指针变量
    cmd_pf = new_cmd;      // 让它指向 new_cmd 函数
    (*cmd_pf)();           // 通过指针调用函数（写法1）
    cmd_pf();              // 通过指针调用函数（写法2，C语言允许省略*）

    printf("------------------------\n");

    // 2. 演示函数指针数组（核心示例）
    void (*file_cmd[])(void) = {
        new_cmd,
        open_cmd,
        save_cmd,
        exit_cmd
    };
    int n = sizeof(file_cmd) / sizeof(file_cmd[0]);

    int choice;
    while (1) {
        printf("\n菜单：\n");
        printf("0 - 新建文件\n");
        printf("1 - 打开文件\n");
        printf("2 - 保存文件\n");
        printf("3 - 退出\n");
        printf("请输入选择 (0-%d): ", n-1);
        scanf("%d", &choice);

        if (choice >= 0 && choice < n) {
            // 通过函数指针数组调用对应函数
            file_cmd[choice]();
        } else {
            printf("无效选择，请重试。\n");
        }
    }

    return 0;
}
```
+ 解析
    + 关于 `void (*file_cmd[])(void)`

    | 语法片段 | 含义 |
    |----------|------|
    | `file_cmd` | 这是**变量名**，代表一个数组 |
    | `file_cmd[]` | 说明 `file_cmd` 是一个**数组**（方括号 `[]` 优先级高于 `*`） |
    | `*file_cmd[]` | 说明数组里的**每个元素都是指针** |
    | `(*file_cmd[])(void)` | 说明这些指针是**函数指针**，`(void)` 表示指向的函数**无参数** |
    | `void (*file_cmd[])(void)` | 最外层的 `void` 表示这些函数指针指向的函数**返回值为 void** |

## 受限指针

+ `restrict` 是给编译器的 `“契约式优化提示”`
    + 它向编译器承诺：`这个指针`是访问其指向内存区域的`唯一合法途径`，不会有任何其他指针（别名）来读写这块内存。
    + 编译器基于`这个承诺`，可以做更激进的性能优化，而不用担心因 “别名干扰” 导致逻辑错误。
    + 高性能数组应用领域
    ```c
        // 无restrict版本：编译器需每次从b[i]读取内存（担心b被其他指针修改）
    void array_add(int *a, int *b, int n) {
        for (int i = 0; i < n; i++) {
            a[i] = b[i] + 10;
        }
    }

    // 有restrict版本：编译器可优化为批量读取b到寄存器，减少内存访问
    void array_add_restrict(int *restrict a, int *restrict b, int n) {
        for (int i = 0; i < n; i++) {
            a[i] = b[i] + 10;
        }
    }
    ```

## 弹性数组成员

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 1. 定义包含弹性数组成员的结构 (C99标准)
// 规则：chars[] 必须是最后一个成员，且结构至少有一个其他成员
struct vstring {
    int len;        // 存储字符串的长度
    char chars[];   // 弹性数组成员：不占结构体大小，长度由malloc决定
};

int main() {
    // 要存储的原始字符串
    const char *text = "Hello, Flexible Array!";
    // 计算字符串长度
    int text_len = strlen(text);

    // 2. 动态分配内存 (核心步骤)
    // 公式：sizeof(结构体) + 数据长度 + 1 (用于存储末尾的\0，方便打印)
    struct vstring *str = malloc(sizeof(struct vstring) + text_len + 1);
    if (str == NULL) {
        perror("malloc failed");
        return 1;
    }

    // 3. 初始化数据
    str->len = text_len;                          // 设置长度
    memcpy(str->chars, text, text_len + 1);       // 拷贝字符串内容(包括\0)

    // 4. 使用数据
    printf("字符串长度: %d\n", str->len);
    printf("字符串内容: %s\n", str->chars);
    
    // 验证结构体大小 (重要特性)
    printf("sizeof(struct vstring) = %zu 字节\n", sizeof(struct vstring));
    // 输出结果通常是 4 (仅int len的大小，chars[] 不占空间)

    // 5. 释放内存 (关键：只需free一次)
    // 虽然分配了结构体+数组的内存，但它们是一块连续的内存，直接free(str)即可
    free(str);
    str = NULL;

    return 0;
}
```

# 输入输出

## 流

+ 在 C 语言中, `术语流 (stream)`表示任意`输入的源`或任意`输出的目的地`。
+ 许多小型程序都是通过`一个流`(通常和键盘相关)获得全部的输入,并且通过`另一个流`(通常和屏幕相关)写出全部的输出。
+ 较大规模的程序可能会需要`额外的流`。
    + 这些流常常表示存储在`不同介质`(如硬盘驱动器、CD、DVD 和闪存)上的`文件`
    + 但也很容易和不存储`文件`的设备(如网络端口、打印机等)相关联。
    + 这里将集中讨论`文件`,因为它们常见且容易理解。